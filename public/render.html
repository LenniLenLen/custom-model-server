<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model Renderer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #renderCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5em;
            text-align: center;
            z-index: 10;
        }
        
        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #e74c3c;
            font-size: 1.2em;
            text-align: center;
            background: rgba(255,255,255,0.9);
            padding: 20px;
            border-radius: 10px;
            z-index: 10;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <div>ðŸŽ® Lade 3D-Modell...</div>
        <div style="font-size: 0.8em; margin-top: 10px;">Bitte warten</div>
    </div>
    
    <div id="error" class="error hidden"></div>
    <canvas id="renderCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        let scene, camera, renderer, controls;
        let model = null;
        let isLoaded = false;
        let hasError = false;
        
        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const modelUrl = urlParams.get('model');
        const textureUrl = urlParams.get('texture');
        const modelType = urlParams.get('type') || 'obj';
        
        function showError(message) {
            hasError = true;
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('error').textContent = message;
            document.getElementById('error').classList.remove('hidden');
        }
        
        function hideLoading() {
            document.getElementById('loading').classList.add('hidden');
        }
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x667eea);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 5);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('renderCanvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-10, -10, -5);
            scene.add(fillLight);
            
            // Controls (disabled for automatic rendering)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 2;
            controls.enableZoom = false;
            controls.enablePan = false;
            
            // Load model
            loadModel();
            
            // Start animation loop
            animate();
        }
        
        function loadModel() {
            if (!modelUrl) {
                showError('Keine Modell-URL angegeben');
                return;
            }
            
            let loader;
            let fileExtension = modelType.toLowerCase();
            
            // Determine loader based on file type
            switch (fileExtension) {
                case 'obj':
                    loader = new THREE.OBJLoader();
                    break;
                case 'gltf':
                case 'glb':
                    loader = new THREE.GLTFLoader();
                    break;
                case 'json':
                    // Try to load as JSON geometry
                    loader = new THREE.ObjectLoader();
                    break;
                default:
                    showError(`Unbekannter Modelltyp: ${fileExtension}`);
                    return;
            }
            
            // Load the model
            loader.load(
                modelUrl,
                function (loadedModel) {
                    handleModelLoad(loadedModel, fileExtension);
                },
                function (progress) {
                    console.log('Loading progress:', (progress.loaded / progress.total * 100) + '%');
                },
                function (error) {
                    console.error('Model loading error:', error);
                    showError(`Fehler beim Laden des Modells: ${error.message || 'Unbekannter Fehler'}`);
                }
            );
        }
        
        function handleModelLoad(loadedModel, fileType) {
            // Handle different loader outputs
            if (fileType === 'gltf' || fileType === 'glb') {
                model = loadedModel.scene || loadedModel;
            } else {
                model = loadedModel;
            }
            
            if (!model) {
                showError('Modell konnte nicht geladen werden');
                return;
            }
            
            // Center and scale model
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            // Center the model
            model.position.sub(center);
            
            // Scale model to fit in view
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 2 / maxDim;
            model.scale.multiplyScalar(scale);
            
            // Apply texture if provided
            if (textureUrl) {
                loadTexture(model, textureUrl);
            }
            
            // Add to scene
            scene.add(model);
            
            // Adjust camera distance
            const scaledSize = maxDim * scale;
            camera.position.set(0, 0, scaledSize * 3);
            controls.target.set(0, 0, 0);
            controls.update();
            
            isLoaded = true;
            hideLoading();
            
            // Signal that rendering is ready
            setTimeout(() => {
                document.body.classList.add('render-ready');
            }, 1000);
        }
        
        function loadTexture(model, textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            
            textureLoader.load(
                textureUrl,
                function (texture) {
                    texture.flipY = false;
                    texture.encoding = THREE.sRGBEncoding;
                    
                    // Apply texture to all mesh materials
                    model.traverse(function (child) {
                        if (child.isMesh) {
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => {
                                        mat.map = texture;
                                        mat.needsUpdate = true;
                                    });
                                } else {
                                    child.material.map = texture;
                                    child.material.needsUpdate = true;
                                }
                            }
                        }
                    });
                },
                function (progress) {
                    console.log('Texture loading progress:', (progress.loaded / progress.total * 100) + '%');
                },
                function (error) {
                    console.warn('Texture loading error:', error);
                    // Continue without texture
                }
            );
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (controls) {
                controls.update();
            }
            
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        // Handle window resize
        window.addEventListener('resize', function () {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
        
        // Initialize when page loads
        window.addEventListener('load', init);
        
        // Add a timeout to prevent infinite loading
        setTimeout(() => {
            if (!isLoaded && !hasError) {
                showError('Laden dauert zu lange - mÃ¶glicherweise ein Problem mit der Modell-URL');
            }
        }, 30000); // 30 seconds timeout
    </script>
</body>
</html>

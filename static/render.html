<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Render Preview</title>
  <style>
    html,body { margin:0; padding:0; background:transparent; }
    #container { width:512px; height:512px; }
  </style>
</head>
<body>
  <div id="container"></div>

  <!-- Three.js + loaders -->
  <script src="https://unpkg.com/three@0.162.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.162.0/examples/js/loaders/OBJLoader.js"></script>
  <script src="https://unpkg.com/three@0.162.0/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    (async () => {
      const container = document.getElementById('container');
      const pathParts = location.pathname.split('/');
      const modelName = decodeURIComponent(pathParts[pathParts.length - 1] || '');
      if (!modelName) { console.error('No modelName'); return; }

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
      camera.position.set(2, 2, 2);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setSize(512, 512);
      container.appendChild(renderer.domElement);

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5,5,5);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));

      // Utility: fetch folder listing from /model-file/<modelName>/
      async function listFiles() {
        // assuming server returns JSON list of files
        const res = await fetch(`/model-file/${encodeURIComponent(modelName)}`);
        if (!res.ok) return [];
        return await res.json();
      }

      // Recursive search function
      function findFile(files, extensions) {
        for (const f of files) {
          const ext = f.toLowerCase().split('.').pop();
          if (extensions.includes(ext)) return f;
        }
        return null;
      }

      // Find model and texture
      let files = [];
      try { files = await listFiles(); } catch(e) { console.warn(e); }

      let modelFile = findFile(files, ['obj','gltf','glb','fbx']);
      let textureFile = findFile(files, ['png']);
      if (!modelFile) {
        // fallback placeholder
        const geometry = new THREE.BoxGeometry(1,1,1);
        const material = new THREE.MeshNormalMaterial();
        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);
        renderer.render(scene, camera);
        window.__THUMB_READY = true;
        return;
      }

      let mesh;
      const loadModel = async () => {
        const ext = modelFile.split('.').pop().toLowerCase();
        const url = `/model-file/${encodeURIComponent(modelName)}/${modelFile}`;

        if (ext === 'obj') {
          const loader = new THREE.OBJLoader();
          mesh = await new Promise(resolve => loader.load(url, obj => resolve(obj)));
        } else if (ext === 'gltf' || ext === 'glb') {
          const loader = new THREE.GLTFLoader();
          const gltf = await new Promise(resolve => loader.load(url, g => resolve(g)));
          mesh = gltf.scene;
        } else if (ext === 'fbx') {
          // optional: FBXLoader if needed
          console.warn('FBX not implemented in this preview');
        }
      };

      await loadModel();

      // Apply texture if found
      if (textureFile && mesh) {
        const texUrl = `/model-file/${encodeURIComponent(modelName)}/${textureFile}`;
        const loader = new THREE.TextureLoader();
        const tex = await new Promise(resolve => loader.load(texUrl, t => resolve(t), undefined, () => resolve(null)));
        mesh.traverse((child) => {
          if (child.isMesh) {
            child.material.map = tex;
            child.material.needsUpdate = true;
          }
        });
      }

      if (mesh) scene.add(mesh);

      // Center & scale
      const box = new THREE.Box3().setFromObject(mesh || scene);
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const scale = 1 / maxDim;
      if (mesh) mesh.scale.setScalar(scale);
      if (mesh) mesh.position.sub(box.getCenter(new THREE.Vector3()).multiplyScalar(scale));

      renderer.render(scene, camera);

      // Done
      window.__THUMB_READY = true;
    })();
  </script>
</body>
</html>
